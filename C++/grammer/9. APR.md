<h1>배열, 포인터, 레퍼런스</h1>
<h3>배열</h3>
배열 선언 방법

```cpp
int x[10];
```
배열은 [ ] 대괄호로 접근한다.

x[i]는 x의 i번째 요소의 레퍼런스이다.

배열은 정의와 동시에 초기화할 수 있다.

```cpp
float v[] = {1.0, 2.0, 3.0};
```
이 경우 배열의 크기를 추론한다.

더 높은 차원의 배열을 정의할 수도 있다.

```cpp
float A[7][9];
int q[3][2][3];
```
배열의 크기는 컴파일 타임에 알고 있어야 한다.

<h3>포인터</h3>
포인터는 메모리 주소를 포함하는 변수다.

이 주소는 주소연산자 또는 동적으로 할당한 메모리로 얻을 수 있는 다른 변수의 주소일 수 있다.

```cpp
int* y = new int[10]; // 동적인 크기의 배열을 할당하는 코드
```

동적 할당을 통해 런타임에 배열의 크기를 정할 수 있다.

```cpp
delete[] v; // 메모리를 해제하는 코드
```

```cpp
int* ip = new int; // 하나의 단일 데이터 항목을 동적으로 할당하는 방법
delete ip; // 메모리를 해제하는 코드
```

& 연산자는 개체를 가져와서 주소를 반환한다.

\* 연산자로 주소를 가져와서 개체를 반환한다.

이를 역참조(Dereferencing)라고 한다.

초기화하지 않은 포인터에는 무작위 값을 할당한다.

```cpp
int* ip3 = nullptr;
int* ip4{};
```
포인터가 무언가를 가리키고 있지 않다는 것을 명시적으로 알려주려면 위 처럼 설정해야한다.

포인터 관련 오류를 최소화하는 전력
* 표준 컨테이너를 사용 : 표준 라이브러리나 유효성이 검증된 라이브러리를 사용해라.
std::vector는 크기 조정 및 범위 검사를 포함한 동적 배열의 모든 기능을 제공한다.
* 캡슐화 : 클래스에서의 동적 메모리 관리. 클래스당 한 번만 처리해야한다.
* 스마트 포인터를 사용하라 : 개체를 참조하고 동적 메모리를 관리한다. 스마트 포인터 타입 3가지 unique_ptr, shared_ptr, weak_ptr. 

<h5>unique_ptr</h5>

참조한 데이터의 고유 소유권 (Unique Ownership)을 나타낸다.

기본적으로 일반 포인터와 같이 사용할 수 있다.

```cpp
#include <memory>
int main(){
    unique_ptr<double> dp{new double};
    *dp = 7;
}
```

포인터가 만료되면 메모리가 자동으로 해제한다.

unique_ptr의 데이터를 얻고 싶다면 멤버함수 get을 사용하면 된다.

다른 unique_ptr에 할당할 수도 없고 이동만 가능하다.

unique_ptr에는 사용자 정의 Deleter 를 제공하는 기능이 있다.

<h5>shared_ptr</h5>

여러 파티에서 공통으로 사용하는 메모리를 관리한다.

shared_ptr가 더 이상 데이터를 참조하지 않는 즉시 메모리를 자동으로 해제한다.

모든 스레드가 스레드에 대한 접근이 끝나면 메모리를 자동으로 해제한다.

shared_ptr는 원하는 만큼 자주 복사할 수 있다.

<h5>weak_ptr</h5>

shared_ptr에서 발생할 수 있는 문제는 메모리 해제를 방해하는 순환참조(Cycle Reference)다.
이러한 순환은 weak_ptr를 통해 중단할 수 있다.

weak_ptr는 공유항더라도 소유권을 주장하지 않는다.

<h3>레퍼런스</h3>

```cpp
int i = 5;
int& j = i;
```
변수 i 는 j 를 참조한다.

j 를 변경하면 i 도 변경되고 반대의 경우도 똑같다.